import os
import requests
import random
import hmac
import time
import simplejson
import string
from urllib import urlencode
import urlparse
import pickle
import oauth2 as oauth

REQUEST_TOKEN_URL = 'http://vimeo.com/oauth/request_token'
ACCESS_TOKEN_URL = 'http://vimeo.com/oauth/access_token'
AUTHORIZATION_URL = 'http://vimeo.com/oauth/authorize'

class Client(object):
    """A client for interacting with Vimeo resources."""
    
    def __init__(self, **kwargs):
        """Create a client instance with the provided options. Options shou        ld be passed in as kwargs."""
	
        self.options = kwargs

	self.key = kwargs.get('key')
	self.secret = kwargs.get('secret')
	self.callback = kwargs.get('callback')
	self.username = kwargs.get('username')

	if 'token' in kwargs:
		self.token = kwargs.get('token')
		return

	if 'key' not in kwargs:
		raise TypeError("At least a key must be provided.")

	if 'username' not in kwargs:
		raise TypeError("Username must be provided.")
	
	self._authorize_url = None
	self.request_token = None
	self.token = None
	self.consumer = oauth.Consumer(key=self.key, secret=self.secret)
	self.client = None	
	self.path = os.path.join("~", ".flickr")


	# decide which protocol flow to follow based on the arguments
        # provided by the caller.
	if self._options_for_authorization_flow_present():
            self._authorization_flow()
        elif self._options_for_credentials_flow_present():
            self._credentials_flow()
        elif self._options_for_token_refresh_present():
            self._refresh_token_flow()

    def exchange_token(self, verifier):
        """Given the value of the verifier, request an access token."""
        
	f = open(self._get_cache_token_filename(), "r")
	self.token = pickle.load(f)
	f.close()
	self.token.set_verifier(verifier)
        self.client = oauth2.Client(self.consumer, self.token)
	self._get_new_token(ACCESS_TOKEN_URL)
        

    def _authorization_flow(self):
	self.client = oauth.Client(self.consumer)
	self._get_new_token(REQUEST_TOKEN_URL)

	# Store self.token in cache.
	path = self.get_cache_token_path()
	if not os.path.exists(path):
		os.makedirs(path)
	f = open(self._get_cache_token_filename(), "w")
	pickle.dump(self.token, f, pickle.HIGHEST_PROTOCOL)
	f.close()

    def authorize_url(self, permission="read"):
        """Return the authorization URL for OAuth2 authorization code flow."""
	if not self.token:
	    self._authorization_flow()
        return "{0}?oauth_token={1}&permission={2}". format(AUTHORIZATION_URL, self.token.key, permission)

    def _is_success(self, headers):
	if headers["status"] != "200":
		raise VimeoError("Invalid response {0}".format(headers["status"]))
	return True

    def _get_new_token(self, request_url):
        """Build the the auth URL so the user can authorize the app."""
	
	resp, content = self.client.request(request_url, "POST", body=urlencode({'oauth_callback': self.callback}))

	if self._is_success(resp):
	    new_token = dict(urlparse.parse_qsl(content))
	    self.token = oauth.Token(new_token["oauth_token"], new_token["oauth_token_secret"])
	    self.client = oauth.Client(self.consumer, self.token)

    def _get_cache_token_path(self):
        """Return the directory holding the app data."""
	return os.path.expanduser(os.path.join(self.path, self.key))

    def _get_cache_token_filename(self):
	"""Return the full pathname of the cache token file."""
	filename = 'auth-%s.token' % self.username
	return os.path.join(self._get_cache_token_path(), filename)


    # Helper functions for testing arguments provided to the constructor.

    def _options_present(self, options, kwargs):
        return all(map(lambda k: k in kwargs, options))

    def _options_for_credentials_flow_present(self):
        required = ('key', 'secret', 'username', 'password')
        return self._options_present(required, self.options)

    def _options_for_authorization_flow_present(self):
        required = ('key', 'secret', 'callback')
        return self._options_present(required, self.options)

    def _options_for_token_refresh_present(self):
        required = ('key', 'secret', 'refresh_token')
        return self._options_present(required, self.options)
	
